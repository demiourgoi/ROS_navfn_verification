in "smtex.maude" .


fmod POSE-VERIF is
  protecting BOOLEAN .
  protecting QUANTIFIER .
  protecting REAL-INTEGER .

  sort Pose .
  sort Point .

  op _===_ : Point Point -> Boolean [ctor gather (e E) prec 51] .
  op _=/==_ : Point Point -> Boolean [ctor gather (e E) prec 51] .
  op _?_:_ : Boolean Point Point -> Point [ctor gather (e e e) prec 71] .

  op point-row : Point -> Integer .
  op point-col : Point -> Integer .

  op point-axiom : Point -> Boolean .
  eq point-axiom(P:Point) = true .

  
  op pose : Point -> Pose [ctor] .

  op _===_ : Pose Pose -> Boolean [ctor gather (e E) prec 51] .
  op _=/==_ : Pose Pose -> Boolean [ctor gather (e E) prec 51] .
  op _?_:_ : Boolean Pose Pose -> Pose [ctor gather (e e e) prec 71] .

  op pose-position : Pose -> Point .
  
  op pose-axiom : Pose -> Boolean .

  eq pose-axiom(P:Pose) = point-axiom(pose-position(P:Pose)) .

  op adjacent-horizontal : Pose Pose -> Boolean .  
  op adjacent-vertical : Pose Pose -> Boolean .  
  op adjacent : Pose Pose -> Boolean .

  
  eq adjacent-horizontal(P1:Pose, P2:Pose) =
    (point-row(pose-position(P1:Pose)) === point-row(pose-position(P2:Pose)) and point-col(pose-position(P1:Pose)) === point-col(pose-position(P2:Pose)) + 1) or
    (point-row(pose-position(P1:Pose)) === point-row(pose-position(P2:Pose)) and point-col(pose-position(P1:Pose)) === point-col(pose-position(P2:Pose)) - 1) .
  
  eq adjacent-vertical(P1:Pose, P2:Pose) =
    (point-col(pose-position(P1:Pose)) === point-col(pose-position(P2:Pose)) and point-row(pose-position(P1:Pose)) === point-row(pose-position(P2:Pose)) + 1) or
    (point-col(pose-position(P1:Pose)) === point-col(pose-position(P2:Pose)) and point-row(pose-position(P1:Pose)) === point-row(pose-position(P2:Pose)) - 1) .
  
  vars P1 P2 : Pose .
  
  eq adjacent(P1, P2) = 
    adjacent-horizontal(P1, P2) or adjacent-vertical(P1, P2) .

  op P! : -> Point .
  ops I! J! : -> Integer [ctor] .
  
endfm

view Pose from TRIV to POSE-VERIF is
        sort Elt to Pose .
endv

fmod COSTMAP-VERIF is
  protecting BOOLEAN .
  protecting QUANTIFIER .
  protecting REAL-INTEGER .
  protecting POSE-VERIF .
  protecting SMT-ARRAY{Integer, Integer} .
  
  
  sort CostMap .
  
  op obstacle-cost : -> Real .
  eq obstacle-cost = toReal(254) .

  op map-cost : -> Real .
  eq map-cost = toReal(50) .

  
  op value : CostMap Point -> Real .
  op num-rows : CostMap -> Integer .
  op num-cols : CostMap -> Integer .

  op costmap-axiom : CostMap -> Boolean .
  op costmap-valid : CostMap -> Boolean .

  var CM : CostMap .
  
  eq costmap-axiom(CM) =
    num-rows(CM) >= 0 and num-cols(CM) >= 0 .

  
  eq costmap-valid(CM) = 
    num-rows(CM) >= 0 and 
    num-cols(CM) >= 0 and
    (forall I! .
    (forall J! . 
      ((0 <= I! and I! < num-rows(CM) and 0 <= J! and J! < num-cols(CM)) 
        implies 
          (forall P! . 
            ((point-row(P!) === I! and point-row(P!) === J!) implies value(CM, P!) > toReal(0)))))) .
  
  
  var I J : Integer .
  
  op open : CostMap Integer Integer -> Boolean .
  eq open(CM:CostMap, I, J:Integer) =
    forall P! . ((point-row(P!) === I and point-col(P!) === J:Integer) implies
      value(CM:CostMap, P!) < obstacle-cost) .
endfm




fmod POTENTIALMAP-VERIF is
  protecting BOOLEAN .
  protecting QUANTIFIER .
  protecting REAL-INTEGER .
  protecting POSE-VERIF .
  protecting COSTMAP-VERIF .

  sort RealInf .

  op _===_ : RealInf RealInf -> Boolean [ctor gather (e E) prec 51] .
  op _=/==_ : RealInf RealInf -> Boolean [ctor gather (e E) prec 51] .
  op _?_:_ : Boolean RealInf RealInf -> RealInf [ctor gather (e e e) prec 71 ] .
  
  op isInfinity : RealInf -> Boolean .
  op unwrapReal : RealInf -> Real .
  
  sort PotentialMap .
  
  op _===_ : PotentialMap PotentialMap -> Boolean [ctor gather (e E) prec 51] .
  op _=/==_ : PotentialMap PotentialMap -> Boolean [ctor gather (e E) prec 51] .
  op _?_:_ : Boolean PotentialMap PotentialMap -> PotentialMap [ctor gather (e e e) prec 71] .
  
  
  op elem : PotentialMap Integer Integer -> RealInf .
  
  op potentialmap-axiom : PotentialMap -> Boolean .
  
  op potentialmap-valid : PotentialMap CostMap -> Boolean .
  op has-adjacent-real : Pose PotentialMap Integer Integer -> Boolean .
  
  
  var PM : PotentialMap .
  var CM : CostMap .
  var P : Pose .
  var NR NC : Integer .
  
  eq potentialmap-axiom(PM) =
    true .
  
  eq potentialmap-valid(PM, CM) =
    forall I! .
    forall J! .
      ((0 <= I! and I! < num-rows(CM) and 0 <= J! and J! < num-cols(CM) and (not isInfinity(elem(PM, I!, J!)))) implies open(CM, I!, J!)) .

  eq has-adjacent-real(P, PM, NR, NC) = 
    0 <= point-row(pose-position(P)) and point-row(pose-position(P)) < NR 
    and 0 <= point-col(pose-position(P)) and point-col(pose-position(P)) < NC
    and 
      (
        (point-row(pose-position(P)) > 0 and not isInfinity(elem(PM, point-row(pose-position(P)) - 1, point-col(pose-position(P)))))
        or 
        (point-row(pose-position(P)) + 1 < NR and not isInfinity(elem(PM, point-row(pose-position(P)) + 1, point-col(pose-position(P)))))
        or
        (point-col(pose-position(P)) > 0 and not isInfinity(elem(PM, point-row(pose-position(P)), point-col(pose-position(P)) - 1)))
        or 
        (point-col(pose-position(P)) + 1 < NC and not isInfinity(elem(PM, point-row(pose-position(P)), point-col(pose-position(P)) + 1)))      
      ) .
  
      
  
endfm


fmod POSE-QUEUE-VERIF is
  protecting BOOLEAN .
  protecting SMT-ARRAY{Integer, Pose} .
  protecting POTENTIALMAP-VERIF .
  protecting COSTMAP-VERIF .

  sort PoseQueue .
  
  subsort Array{Integer,Pose} < PoseQueue .
  
  op length : PoseQueue -> Integer .
  op queue-array : PoseQueue -> Array{Integer,Pose} .
  
  op enqueue : Pose PoseQueue PoseQueue -> Boolean .
  op dequeue : PoseQueue PoseQueue -> Boolean .
  op empty : PoseQueue -> Boolean .
  op front : PoseQueue Pose -> Boolean .
  
  op queue-axiom : PoseQueue -> Boolean .
  op queue-valid : PoseQueue PotentialMap CostMap -> Boolean .
  
  op _===_ : PoseQueue PoseQueue -> Boolean [ctor gather (e E) prec 51] .
  op _=/==_ : PoseQueue PoseQueue -> Boolean [ctor gather (e E) prec 51] .
  op _?_:_ : Boolean PoseQueue PoseQueue -> PoseQueue [ctor gather (e e e) prec 71] .
  
  
  vars Q Q1 Q2 : PoseQueue .
  var P : Pose .
  var PM : PotentialMap .
  var CM : CostMap .
  
  eq queue-axiom(Q) =
    length(Q) >= 0 and forall I! . pose-axiom(queue-array(Q)[I!]) .
  
  eq enqueue(P, Q1, Q2) =
    length(Q2) === length(Q1) + 1 
    and queue-array(Q2) === queue-array(Q1)[length(Q1) -> P] .
    
  eq dequeue(Q1, Q2) = 
    length(Q2) > 0 
    and length(Q2) === length(Q1) - 1
    and (forall I! . ((0 <= I! and I! < length(Q2)) implies (queue-array(Q2)[I!] === queue-array(Q1)[I! + 1]))) .
  
  eq empty(Q) = length(Q) === 0 .
  
  eq front(Q, P) = length(Q) > 0 and queue-array(Q)[0] === P .
  
  
  eq queue-valid(Q, PM, CM) =
    forall I! . ((0 <= I! and I! < length(Q)) 
      implies
        (
          0 <= point-row(pose-position(queue-array(Q)[I!])) and point-row(pose-position(queue-array(Q)[I!])) < num-rows(CM)
        and 
          0 <= point-col(pose-position(queue-array(Q)[I!])) and point-col(pose-position(queue-array(Q)[I!])) < num-cols(CM)
         and
          has-adjacent-real(queue-array(Q)[I!], PM, num-rows(CM), num-cols(CM))          
        )) .
endfm


fmod BUILD-INITIAL-POTENTIAL-MAP-VERIF is
  protecting POTENTIALMAP-VERIF .
  
  op build-initial-potential-map-precond : 
    Integer Integer Integer Integer -> Boolean .
    
  op build-initial-potential-map-postcond : 
    Integer Integer Integer Integer PotentialMap -> Boolean .
  
  var NR NC INITR INITC : Integer .
  var PM : PotentialMap .
  
  eq build-initial-potential-map-precond(NR, NC, INITR, INITC) =
    *** requires 0 <= initRow < numRows && 0 <= initCol < numCols
    0 <= INITR and INITR < NR and 0 <= INITC and INITC < NC .
    
  eq build-initial-potential-map-postcond(NR, NC, INITR, INITC, PM) =
    *** ensures PotentialMapHasDimensions(p, numRows, numCols)
    *** ensures forall i, j | 0 <= i < numRows && 0 <= j < numCols 
    ***           && (i != initRow || j != initCol) :: p[i][j] == Infinity
    (forall I! . forall J! . 
      ((
        0 <= I! and I! < NR and 0 <= J! 
        and J! < NC and (I! =/== INITR or J! =/== INITC)
      )
      implies (
          isInfinity(elem(PM, I!, J!))
      )))
    *** ensures p[initRow][initCol] == Real(0.0)
    and (not isInfinity(elem(PM, INITR, INITC))) 
    and (unwrapReal(elem(PM, INITR, INITC)) === toReal(0)) .
endfm


fmod EUCLID-DISTANCE-VERIF is
  protecting POSE-VERIF .
  protecting REAL-INTEGER .
  
  
  vars P1 P2 : Point .
  var D : Real .
  
  op euclid-distance-precond : Point Point -> Boolean .
  op euclid-distance-postcond : Point Point Real -> Boolean .
  
  eq euclid-distance-precond(P1, P2) = true .
  eq euclid-distance-postcond(P1, P2, D) = true .
  
  op abs : Real Real -> Boolean .
  
  ops DIFFR! DIFFC! : -> Real .
  
  vars R R1 : Real .
  
  eq abs(R, R1) =
    (R >= toReal(0) implies R1 === R)
    and ((not R >= toReal(0)) implies R1 === toReal(0) - R) .
  
  op euclid-distance : Point Point Real -> Boolean .
  
  eq euclid-distance(P1, P2, D) =
    forall DIFFR! . forall DIFFC! .
      ((
        abs(toReal(point-row(P1) - point-row(P2)), DIFFR!)
        and abs(toReal(point-col(P1) - point-col(P2)), DIFFC!)
      ) implies (
        D === DIFFR! * DIFFR! + DIFFC! * DIFFC!
      )) .
    
  
  
endfm

fmod INIT-CURRENT-QUEUE-VERIF is
  protecting POSE-VERIF .
  protecting POTENTIALMAP-VERIF .
  protecting COSTMAP-VERIF .
  protecting POSE-QUEUE-VERIF .
  
  op init-current-queue-precond : Pose PotentialMap CostMap -> Boolean .
  op init-current-queue-postcond : Pose PotentialMap CostMap PoseQueue -> Boolean .
  
  var P : Pose .
  var PM : PotentialMap .
  var CM : CostMap .
  var PQ : PoseQueue .
  
  eq init-current-queue-precond(P, PM, CM) =
    *** Input invariants
    pose-axiom(P)
    and potentialmap-axiom(PM)
    and costmap-axiom(CM)
    *** requires 0 <= p.pos.row < costMap.numRows && 0 <= p.pos.col < costMap.numCols
    and 0 <= point-row(pose-position(P))
    and point-row(pose-position(P)) < num-rows(CM)
    and 0 <= point-col(pose-position(P))
    and point-col(pose-position(P)) < num-cols(CM)
    *** requires pot[p.pos.row][p.pos.col].Real?
    and not isInfinity(elem(PM, point-row(pose-position(P)), point-col(pose-position(P)))) .


  eq init-current-queue-postcond(P, PM, CM, PQ) =
    *** Output invariants
    queue-axiom(PQ)
    *** ensures ValidQueue(current, pot, costMap)
    and queue-valid(PQ, PM, CM) .
    
  
  ops Q0L! Q1L! Q2L! Q3L! Q4L! : -> PoseQueue .
  ops PAUX1! PAUX2! PAUX3! PAUX4! : -> Pose .
  
  op init-current-queue-vc1 : Pose PotentialMap CostMap PoseQueue -> Boolean .
  
  eq init-current-queue-vc1(P, PM, CM, PQ) =
    forall PAUX1! . forall PAUX2! . forall PAUX3! . forall PAUX4! .
    forall Q0L! . forall Q1L! . forall Q2L! . forall Q3L! . forall Q4L! .
    ((
      init-current-queue-precond(P, PM, CM)
      and empty(Q0L!)
      and point-row(pose-position(PAUX1!)) === point-row(pose-position(P)) - 1
      and point-col(pose-position(PAUX1!)) === point-col(pose-position(P))
      and point-row(pose-position(PAUX2!)) === point-row(pose-position(P)) + 1
      and point-col(pose-position(PAUX2!)) === point-col(pose-position(P))
      and point-row(pose-position(PAUX3!)) === point-row(pose-position(P))
      and point-col(pose-position(PAUX3!)) === point-col(pose-position(P)) - 1
      and point-row(pose-position(PAUX4!)) === point-row(pose-position(P))
      and point-col(pose-position(PAUX4!)) === point-col(pose-position(P)) + 1
      and
      ((
        point-row(pose-position(P)) > 0
        and open(CM, point-row(pose-position(P)) - 1, point-col(pose-position(P)))
      ) implies (
        enqueue(PAUX1!, Q0L!, Q1L!)
      ))
      and
      ((
        not (point-row(pose-position(P)) > 0
        and open(CM, point-row(pose-position(P)) - 1, point-col(pose-position(P))))
      ) implies (
        Q1L! === Q0L!
      ))
      and
      ((
        point-row(pose-position(P)) + 1 < num-rows(CM)
        and open(CM, point-row(pose-position(P)) + 1, point-col(pose-position(P)))
      ) implies (
        enqueue(PAUX2!, Q1L!, Q2L!)
      ))      
      and
      (( not (
        point-row(pose-position(P)) + 1 < num-rows(CM)
        and open(CM, point-row(pose-position(P)) + 1, point-col(pose-position(P))))
      ) implies (
        Q2L! === Q1L!
      ))      
      and
      ((
        point-col(pose-position(P)) > 0
        and open(CM, point-row(pose-position(P)), point-col(pose-position(P)) - 1)
      ) implies (
        enqueue(PAUX3!, Q2L!, Q3L!)
      ))
      and
      (( not (
        point-col(pose-position(P)) > 0
        and open(CM, point-row(pose-position(P)), point-col(pose-position(P)) - 1))
      ) implies (
        Q3L! === Q2L!
      ))
      and
      ((
        point-col(pose-position(P)) + 1 < num-cols(CM)
        and open(CM, point-row(pose-position(P)), point-col(pose-position(P)) + 1)
      ) implies (
        enqueue(PAUX4!, Q3L!, Q4L!)
      ))      
      and
      ((not (
        point-col(pose-position(P)) + 1 < num-cols(CM)
        and open(CM, point-row(pose-position(P)), point-col(pose-position(P)) + 1))
      ) implies (
        Q4L! === Q3L!
      ))
      and
      PQ === Q4L!      
    ) implies (
      init-current-queue-postcond(P, PM, CM, PQ)
    )) .
endfm

fmod MIN-INFINITY-VERIF  is
  protecting POTENTIALMAP-VERIF .
  
  op min-infinity : RealInf RealInf RealInf -> Boolean .
  
  vars X1 X2 MIN : RealInf . 

  eq min-infinity(X1, X2, MIN) =
    (isInfinity(X1) implies MIN === X2)
    and
    ((not isInfinity(X1) and isInfinity(X2)) implies MIN === X1)
    and
    ((not isInfinity(X1) and not isInfinity(X2) and unwrapReal(X1) <= unwrapReal(X2)) implies MIN === X1)
    and
    ((not isInfinity(X1) and not isInfinity(X2) and not unwrapReal(X1) <= unwrapReal(X2)) implies MIN === X2) .
endfm

fmod MAX-INFINITY-VERIF  is
  protecting POTENTIALMAP-VERIF .
  
  op max-infinity : RealInf RealInf RealInf -> Boolean .
  
  vars X1 X2 MAX : RealInf . 

  eq max-infinity(X1, X2, MAX) =
    (isInfinity(X1) implies MAX === X1)
    and
    ((not isInfinity(X1) and isInfinity(X2)) implies MAX === X2)
    and
    ((not isInfinity(X1) and not isInfinity(X2) and unwrapReal(X1) >= unwrapReal(X2)) implies MAX === X1)
    and
    ((not isInfinity(X1) and not isInfinity(X2) and not unwrapReal(X1) >= unwrapReal(X2)) implies MAX === X2) .
endfm

fmod MINUS-VERIF is
  protecting POTENTIALMAP-VERIF .
  
  vars R1 R2 R : RealInf .
  
  op minus-precond : RealInf RealInf -> Boolean .
 
  eq minus-precond(R1, R2) = not isInfinity(R2) .
  
  op minus : RealInf RealInf RealInf -> Boolean .
  
  eq minus(R1, R2, R) =
    (isInfinity(R1) implies isInfinity(R))
    and
    ((not isInfinity(R1)) implies (not isInfinity(R) and unwrapReal(R) === unwrapReal(R1) - unwrapReal(R2))) .
endfm

fmod GREATER-THAN-VERIF is
  protecting POTENTIALMAP-VERIF .
  
  vars R1 R2 : RealInf .
  
  op greater-than-precond : RealInf RealInf -> Boolean .

  eq greater-than-precond(R1, R2) =
    not isInfinity(R1) or not isInfinity(R2) .
    


  op greater-than : RealInf RealInf -> Boolean .
  eq greater-than(R1, R2) =
    isInfinity(R1) or
    (not isInfinity(R2) and unwrapReal(R1) > unwrapReal(R2)) .
  
  
endfm

fmod MIN-HORIZONTAL-VERIF is
  protecting POSE-VERIF .
  protecting POTENTIALMAP-VERIF .
  protecting MIN-INFINITY-VERIF  .
  
  op min-horizontal-precond : Pose PotentialMap CostMap Integer -> Boolean .
  
  op min-horizontal-postcond : Pose PotentialMap CostMap Integer RealInf -> Boolean .
  
  var P : Pose .
  var PM : PotentialMap .
  var CM : CostMap .
  var NC : Integer .
  var RESULT : RealInf .
  
  eq min-horizontal-precond(P, PM, CM, NC) =
    NC >= 0
    and potentialmap-valid(PM, CM)
    and num-cols(CM) === NC
    and 0 <= point-row(pose-position(P))
    and point-row(pose-position(P)) < num-rows(CM)
    and 0 <= point-col(pose-position(P))
    and point-col(pose-position(P)) < NC .
  
  ops LEFT! RIGHT! : -> RealInf .
  
  eq min-horizontal-postcond(P, PM, CM, NC, RESULT) = 
    forall LEFT! . forall RIGHT! .
      ((
       (point-col(pose-position(P)) > 0 implies LEFT! === elem(PM, point-row(pose-position(P)), point-col(pose-position(P)) - 1))
       and
       ((not point-col(pose-position(P)) > 0) implies isInfinity(LEFT!))
       and
       (point-col(pose-position(P)) + 1 < NC implies RIGHT! === elem(PM, point-row(pose-position(P)), point-col(pose-position(P)) + 1))
       and
       ((not point-col(pose-position(P)) + 1 < NC) implies isInfinity(RIGHT!))
      ) implies (
        min-infinity(LEFT!, RIGHT!, RESULT)
      )) .
endfm

fmod MIN-VERTICAL-VERIF is
  protecting POSE-VERIF .
  protecting POTENTIALMAP-VERIF .
  protecting MIN-INFINITY-VERIF .
  
  op min-vertical-precond : Pose PotentialMap CostMap Integer -> Boolean .  
  op min-vertical-postcond : Pose PotentialMap CostMap Integer RealInf -> Boolean .
   
  var P : Pose .
  var PM : PotentialMap .
  var CM : CostMap .
  var NR : Integer .
  var RESULT : RealInf .
  
    
  
  eq min-vertical-precond(P, PM, CM, NR) =
    NR >= 0
    and num-rows(CM) === NR
    and potentialmap-valid(PM, CM)
    and 0 <= point-row(pose-position(P))
    and point-row(pose-position(P)) < NR
    and 0 <= point-col(pose-position(P))
    and point-col(pose-position(P)) < num-cols(CM) .
  
  ops UP! DOWN! : -> RealInf .
  
  eq min-vertical-postcond(P, PM, CM, NR, RESULT) = 
    forall UP! . forall DOWN! .
      ((
       (point-row(pose-position(P)) > 0 implies UP! === elem(PM, point-row(pose-position(P)) - 1, point-col(pose-position(P))))
       and
       ((not point-row(pose-position(P)) > 0) implies isInfinity(UP!))
       and
       (point-row(pose-position(P)) + 1 < NR implies DOWN! === elem(PM, point-row(pose-position(P)) + 1, point-col(pose-position(P))))
       and
       ((not point-row(pose-position(P)) + 1 < NR) implies isInfinity(DOWN!))
      ) implies (
        min-infinity(UP!, DOWN!, RESULT)
      )) .
endfm


fmod UPDATE-POTENTIAL-VERIF is
  protecting POTENTIALMAP-VERIF .
  protecting POSE-VERIF .
  protecting COSTMAP-VERIF .
  protecting REAL-INTEGER .
  protecting MINUS-VERIF .
  protecting GREATER-THAN-VERIF .
  
  op update-potential-precond : PotentialMap Pose Pose CostMap RealInf RealInf -> Boolean .
  op update-potential-postcond : PotentialMap Pose Pose CostMap RealInf RealInf PotentialMap -> Boolean .
  
  var PM PM' : PotentialMap .
  vars P GOAL : Pose .
  var CM : CostMap .
  vars MIN SND : RealInf .
  
  eq update-potential-precond(PM, P, GOAL, CM, MIN, SND) =
    *** Datatype axioms
    potentialmap-axiom(PM)
    and pose-axiom(P)
    and pose-axiom(GOAL)
    and costmap-axiom(CM)
    *** requires ValidPotentialMap(pot, costMap)
    and potentialmap-valid(PM, CM)
    *** requires ValidCostMap(costMap)
    and costmap-valid(CM)
    *** requires 0 <= p.pos.row < costMap.numRows && 0 <= p.pos.col < costMap.numCols
    and 0 <= point-row(pose-position(P))
    and point-row(pose-position(P)) < num-rows(CM)
    and 0 <= point-col(pose-position(P))
    and point-col(pose-position(P)) < num-cols(CM)
    *** requires min.Real?
    and not isInfinity(MIN)
    *** requires open(costMap, p.pos.row, p.pos.col)
    and open(CM, point-row(pose-position(P)), point-col(pose-position(P))) 
    .
    
  eq update-potential-postcond(PM, P, GOAL, CM, MIN, SND, PM') =
    *** Datatype axioms
    potentialmap-axiom(PM')
    *** ensures ValidPotentialMap(pot', costMap)
    and potentialmap-valid(PM', CM)
    *** ensures forall i, j | 0 <= i < costMap.numRows && 0 <= j < costMap.numCols ::
    ***                           pot[i][j].Real? ==> pot'[i][j].Real?
    and (forall I! . forall J! . 
      ((
        0 <= I! and I! < num-rows(CM)
        and 0 <= J! and J! < num-cols(CM)
        and not isInfinity(elem(PM, I!, J!))
      ) implies (
        not isInfinity(elem(PM', I!, J!))
      )))
    *** ensures pot'[p.pos.row][p.pos.col].Real?
    and not isInfinity(elem(PM', point-row(pose-position(P)), point-col(pose-position(P))))
    .
  
  ops HF! D! INTERPOL! : -> Real .
  ops HFR! DIFF! : -> RealInf .
  op POINT!  : -> Point .
    

    
    
  op update-potential-vc1 : PotentialMap Pose Pose CostMap RealInf RealInf PotentialMap -> Boolean .
  
  *** Call to minus meets precondition
  eq update-potential-vc1(PM, P, GOAL, CM, MIN, SND, PM') =
    forall HF! . forall POINT! . (
      (
        update-potential-precond(PM, P, GOAL, CM, MIN, SND)
        and point-row(POINT!) === point-row(pose-position(P))
        and point-col(POINT!) === point-col(pose-position(P))
        and HF! === value(CM, POINT!)        
      ) implies (
        minus-precond(SND, MIN)
      )
    ) .

  *** Call to greater-than meets precondition    
  op update-potential-vc2 : PotentialMap Pose Pose CostMap RealInf RealInf PotentialMap -> Boolean .
  eq update-potential-vc2(PM, P, GOAL, CM, MIN, SND, PM') =
    forall HF! . forall HFR! . forall DIFF! . forall POINT! . (
      (
        update-potential-precond(PM, P, GOAL, CM, MIN, SND)
        and point-row(POINT!) === point-row(pose-position(P))
        and point-col(POINT!) === point-col(pose-position(P))
        and HF! === value(CM, POINT!)
        and minus(SND, MIN, DIFF!)
        and not isInfinity(HFR!)
        and unwrapReal(HFR!) === HF!
      ) implies (
        greater-than-precond(DIFF!, HFR!)
      )
    ) .
    
  op VREAL! : -> Real .
  op V! : -> RealInf .
    
  *** Case diff > hf
  op update-potential-vc3 : PotentialMap Pose Pose CostMap RealInf RealInf PotentialMap -> Boolean .
  eq update-potential-vc3(PM, P, GOAL, CM, MIN, SND, PM') =
    forall HF! . forall HFR! . forall DIFF! . forall POINT! .
    forall VREAL! . forall V! . (
      (
        update-potential-precond(PM, P, GOAL, CM, MIN, SND)
        and point-row(POINT!) === point-row(pose-position(P))
        and point-col(POINT!) === point-col(pose-position(P))
        and HF! === value(CM, POINT!)
        and minus(SND, MIN, DIFF!)
        and not isInfinity(HFR!)
        and unwrapReal(HFR!) === HF!
        and greater-than(DIFF!, HFR!)
        and VREAL! === HF! + unwrapReal(MIN)
        and not isInfinity(V!)
        and unwrapReal(V!) === VREAL!
        and elem(PM', point-row(pose-position(P)), point-col(pose-position(P)))
          === V!
        and (forall I! . forall J! . 
          ((I! =/== point-row(pose-position(P)) or J! =/== point-col(pose-position(P)))
          implies (elem(PM', I!, J!) === elem(PM, I!, J!))))
      ) implies (
        update-potential-postcond(PM, P, GOAL, CM, MIN, SND, PM')
      )
    ) .
    
  *** case diff <= h: assert diff.Real?;
  op update-potential-vc4 : PotentialMap Pose Pose CostMap RealInf RealInf PotentialMap -> Boolean .
  eq update-potential-vc4(PM, P, GOAL, CM, MIN, SND, PM') =
    forall HF! . forall HFR! . forall DIFF! . forall POINT! .
    (
      (
        update-potential-precond(PM, P, GOAL, CM, MIN, SND)
        and point-row(POINT!) === point-row(pose-position(P))
        and point-col(POINT!) === point-col(pose-position(P))
        and HF! === value(CM, POINT!)
        and minus(SND, MIN, DIFF!)
        and not isInfinity(HFR!)
        and unwrapReal(HFR!) === HF!
        and not greater-than(DIFF!, HFR!)
      ) implies (
        not isInfinity(DIFF!)
      )
    ) .
  
  *** case diff <= h: postcondition
  op update-potential-vc5 : PotentialMap Pose Pose CostMap RealInf RealInf PotentialMap -> Boolean .
  eq update-potential-vc5(PM, P, GOAL, CM, MIN, SND, PM') =
    forall HF! . forall HFR! . forall DIFF! . forall POINT! .
    forall D! . forall INTERPOL! . forall VREAL! . forall V! . (
      (
        update-potential-precond(PM, P, GOAL, CM, MIN, SND)
        and point-row(POINT!) === point-row(pose-position(P))
        and point-col(POINT!) === point-col(pose-position(P))
        and HF! === value(CM, POINT!)
        and minus(SND, MIN, DIFF!)
        and not isInfinity(HFR!)
        and unwrapReal(HFR!) === HF!
        and not greater-than(DIFF!, HFR!)
        and not isInfinity(DIFF!)
        and D! === unwrapReal(DIFF!) / HF!
        *** Cannot define INTERPOL! Â¿Real numbers in Maude?
        and VREAL! === unwrapReal(MIN) + HF! * INTERPOL!
        and not isInfinity(V!)
        and unwrapReal(V!) === VREAL!
        and elem(PM', point-row(pose-position(P)), point-col(pose-position(P)))
          === V!
        and (forall I! . forall J! . 
          ((I! =/== point-row(pose-position(P)) or J! =/== point-col(pose-position(P)))
          implies (elem(PM', I!, J!) === elem(PM, I!, J!))))
      ) implies (
        update-potential-postcond(PM, P, GOAL, CM, MIN, SND, PM')
      )
    ) .

endfm

fmod TRAVERSE-NEIGHBOUR-VERIF is
  protecting POSE-VERIF .
  protecting COSTMAP-VERIF .
  protecting POTENTIALMAP-VERIF .
  protecting REAL-INTEGER .
  protecting POSE-QUEUE-VERIF .
  protecting EUCLID-DISTANCE-VERIF .
  protecting GREATER-THAN-VERIF .

  op traverse-neighbour-precond : Pose Pose Pose CostMap PotentialMap Real PoseQueue PoseQueue -> Boolean .

  op traverse-neighbour-postcond : Pose Pose Pose CostMap PotentialMap Real PoseQueue PoseQueue PoseQueue PoseQueue -> Boolean .
  
  vars P NP START : Pose .
  vars CM : CostMap .
  vars PM : PotentialMap .
  var TH : Real .
  var NEXT EXCESS NEXT' EXCESS' : PoseQueue .
  
  eq traverse-neighbour-precond(P, NP, START, CM, PM, TH, NEXT, EXCESS) =
    *** Datatype axioms
    pose-axiom(P)
    and pose-axiom(NP)
    and pose-axiom(START)
    and costmap-axiom(CM)
    and potentialmap-axiom(PM)
    and queue-axiom(NEXT)
    and queue-axiom(EXCESS)
    *** requires ValidPotentialMap(pot, costMap)
    and potentialmap-valid(PM, CM)
    *** requires 0 <= p.pos.row < costMap.numRows && 0 <= p.pos.col < costMap.numCols
    and 0 <= point-row(pose-position(P))
    and point-row(pose-position(P)) < num-rows(CM)
    and 0 <= point-col(pose-position(P))
    and point-col(pose-position(P)) < num-cols(CM)
    *** requires 0 <= newP.pos.row < costMap.numRows && 0 <= newP.pos.col < costMap.numCols    
    and 0 <= point-row(pose-position(NP))
    and point-row(pose-position(NP)) < num-rows(CM)
    and 0 <= point-col(pose-position(NP))
    and point-col(pose-position(NP)) < num-cols(CM)
    *** requires Adjacent(p, newP, costMap)
    and adjacent(P, NP)
    *** requires pot[p.pos.row][p.pos.col].Real?
    and not isInfinity(elem(PM, point-row(pose-position(P)), point-col(pose-position(P))))
    *** requires ValidQueue(next) && ValidQueue(excess)
    and queue-valid(NEXT, PM, CM)
    and queue-valid(EXCESS, PM, CM) .

  eq traverse-neighbour-postcond(P, NP, START, CM, PM, TH, NEXT, EXCESS, NEXT', EXCESS') =
    queue-axiom(NEXT')
    and queue-axiom(EXCESS')
    and queue-valid(NEXT', PM, CM)
    and queue-valid(EXCESS', PM, CM) .
    
  op traverse-neighbour-vc1 : Pose Pose Pose CostMap PotentialMap Real PoseQueue PoseQueue PoseQueue PoseQueue -> Boolean .
    
  ops H! SQRT2! : -> Real .
  op RHS! : -> RealInf .
    
  *** Precondition of greatherThan
  eq traverse-neighbour-vc1(P, NP, START, CM, PM, TH, NEXT, EXCESS, NEXT', EXCESS') = 
    forall H! . forall RHS! . forall SQRT2! .
    ((
      traverse-neighbour-precond(P, NP, START, CM, PM, TH, NEXT, EXCESS)
      and euclid-distance(pose-position(P), pose-position(START), H!)
      and SQRT2! * SQRT2! === toReal(2)
      and not isInfinity(elem(PM, point-row(pose-position(P)), point-col(pose-position(P))))
      and not isInfinity(RHS!)
      and unwrapReal(RHS!) === 
        unwrapReal(elem(PM, point-row(pose-position(P)), point-col(pose-position(P)))) + H! + (toReal(1) / SQRT2!) * value(CM, pose-position(NP))
    ) implies (
      greater-than-precond(elem(PM, point-row(pose-position(NP)), point-col(pose-position(NP))), RHS!)
    )) .


  op traverse-neighbour-vc2 : Pose Pose Pose CostMap PotentialMap Real PoseQueue PoseQueue PoseQueue PoseQueue -> Boolean .

  *** Case 1: !GreaterThan(PM[NEWP], ...)
  eq traverse-neighbour-vc2(P, NP, START, CM, PM, TH, NEXT, EXCESS, NEXT', EXCESS') = 
    forall H! . forall RHS! . forall SQRT2! .
    ((
      traverse-neighbour-precond(P, NP, START, CM, PM, TH, NEXT, EXCESS)
      and euclid-distance(pose-position(P), pose-position(START), H!)
      and SQRT2! * SQRT2! === toReal(2)
      and not isInfinity(elem(PM, point-row(pose-position(P)), point-col(pose-position(P))))
      and not isInfinity(RHS!)
      and unwrapReal(RHS!) === 
        unwrapReal(elem(PM, point-row(pose-position(P)), point-col(pose-position(P)))) + H! + (toReal(1) / SQRT2!) * value(CM, pose-position(NP))
      and not greater-than(elem(PM, point-row(pose-position(NP)), point-col(pose-position(NP))), RHS!)
      and NEXT' === NEXT
      and EXCESS' === EXCESS
    ) implies (
      traverse-neighbour-postcond(P, NP, START, CM, PM, TH, NEXT, EXCESS, NEXT', EXCESS')
    )) .
  

  op traverse-neighbour-vc3 : Pose Pose Pose CostMap PotentialMap Real PoseQueue PoseQueue PoseQueue PoseQueue -> Boolean .

  *** Case 2: GreaterThan(PM[NEWP], ...), but PM[P] + H < Threshold
  eq traverse-neighbour-vc3(P, NP, START, CM, PM, TH, NEXT, EXCESS, NEXT', EXCESS') = 
    forall H! . forall RHS! . forall SQRT2! .
    ((
      traverse-neighbour-precond(P, NP, START, CM, PM, TH, NEXT, EXCESS)
      and euclid-distance(pose-position(P), pose-position(START), H!)
      and SQRT2! * SQRT2! === toReal(2)
      and not isInfinity(elem(PM, point-row(pose-position(P)), point-col(pose-position(P))))
      and not isInfinity(RHS!)
      and unwrapReal(RHS!) === 
        unwrapReal(elem(PM, point-row(pose-position(P)), point-col(pose-position(P)))) + H! + (toReal(1) / SQRT2!) * value(CM, pose-position(NP))
      and greater-than(elem(PM, point-row(pose-position(NP)), point-col(pose-position(NP))), RHS!)
      and unwrapReal(elem(PM, point-row(pose-position(P)), point-col(pose-position(P)))) + H! < TH
      and enqueue(NP, NEXT, NEXT')
      and EXCESS' === EXCESS
    ) implies (
      traverse-neighbour-postcond(P, NP, START, CM, PM, TH, NEXT, EXCESS, NEXT', EXCESS')
    )) .

  op traverse-neighbour-vc4 : Pose Pose Pose CostMap PotentialMap Real PoseQueue PoseQueue PoseQueue PoseQueue -> Boolean .

  *** Case 3: GreaterThan(PM[NEWP], ...), but PM[P] + H >= Threshold
  eq traverse-neighbour-vc4(P, NP, START, CM, PM, TH, NEXT, EXCESS, NEXT', EXCESS') = 
    forall H! . forall RHS! . forall SQRT2! .
    ((
      traverse-neighbour-precond(P, NP, START, CM, PM, TH, NEXT, EXCESS)
      and euclid-distance(pose-position(P), pose-position(START), H!)
      and SQRT2! * SQRT2! === toReal(2)
      and not isInfinity(elem(PM, point-row(pose-position(P)), point-col(pose-position(P))))
      and not isInfinity(RHS!)
      and unwrapReal(RHS!) === 
        unwrapReal(elem(PM, point-row(pose-position(P)), point-col(pose-position(P)))) + H! + (toReal(1) / SQRT2!) * value(CM, pose-position(NP))
      and greater-than(elem(PM, point-row(pose-position(NP)), point-col(pose-position(NP))), RHS!)
      and not unwrapReal(elem(PM, point-row(pose-position(P)), point-col(pose-position(P)))) + H! < TH
      and NEXT' === NEXT
      and enqueue(NP, EXCESS, EXCESS')
    ) implies (
      traverse-neighbour-postcond(P, NP, START, CM, PM, TH, NEXT, EXCESS, NEXT', EXCESS')
    )) .
    
endfm

fmod TRAVERSE-NEIGHBOURS-VERIF is
  protecting POSE-VERIF .
  protecting COSTMAP-VERIF .
  protecting POTENTIALMAP-VERIF .
  protecting REAL-INTEGER .
  protecting POSE-QUEUE-VERIF .
  protecting TRAVERSE-NEIGHBOUR-VERIF .
  
  op traverse-neighbours-precond : Pose Pose CostMap PotentialMap Real PoseQueue PoseQueue -> Boolean .
  op traverse-neighbours-postcond : Pose Pose CostMap PotentialMap Real PoseQueue PoseQueue PoseQueue PoseQueue -> Boolean .
  
  
  vars P START : Pose .
  var CM : CostMap .
  var PM : PotentialMap .
  var TH : Real .
  var NEXT EXCESS NEXT' EXCESS' : PoseQueue .
  
  eq traverse-neighbours-precond(P, START, CM, PM, TH, NEXT, EXCESS) =
    *** Datatype axioms
    pose-axiom(P)
    and pose-axiom(START)
    and costmap-axiom(CM)
    and potentialmap-axiom(PM)
    and queue-axiom(NEXT)
    and queue-axiom(EXCESS)
    *** requires ValidPotentialMap(pot, costMap)
    and potentialmap-valid(PM, CM)
    *** requires ValidQueue(next, pot, costMap) && ValidQueue(excess, pot, costMap)
    and queue-valid(NEXT, PM, CM) and queue-valid(EXCESS, PM, CM)    
    *** requires 0 <= p.pos.row < costMap.numRows && 0 <= p.pos.col < costMap.numCols
    and 0 <= point-row(pose-position(P))
    and point-row(pose-position(P)) < num-rows(CM)
    and 0 <= point-col(pose-position(P))
    and point-col(pose-position(P)) < num-cols(CM)
    *** requires pot[p.pos.row][p.pos.col].Real?
    and not isInfinity(elem(PM, point-row(pose-position(P)), point-col(pose-position(P))))
    .
    
  eq traverse-neighbours-postcond(P, START, CM, PM, TH, NEXT, EXCESS, NEXT', EXCESS') =
    *** Datatype axioms
    queue-axiom(NEXT')
    and queue-axiom(EXCESS')
    *** ensures ValidQueue(next', pot, costMap) && ValidQueue(excess', pot, costMap)
    and queue-valid(NEXT', PM, CM) and queue-valid(EXCESS', PM, CM) .
    
  op traverse-neighbours-vc1 : Pose Pose CostMap PotentialMap Real PoseQueue PoseQueue PoseQueue PoseQueue -> Boolean .
  op traverse-neighbours-vc2 : Pose Pose CostMap PotentialMap Real PoseQueue PoseQueue PoseQueue PoseQueue -> Boolean .
  op traverse-neighbours-vc3 : Pose Pose CostMap PotentialMap Real PoseQueue PoseQueue PoseQueue PoseQueue -> Boolean .
  op traverse-neighbours-vc4 : Pose Pose CostMap PotentialMap Real PoseQueue PoseQueue PoseQueue PoseQueue -> Boolean .
  op traverse-neighbours-vc5 : Pose Pose CostMap PotentialMap Real PoseQueue PoseQueue PoseQueue PoseQueue -> Boolean .
  
  ops NP1! NP2! NP3! NP4! : -> Pose .
  ops NEXT1! EXCESS1! NEXT2! EXCESS2! NEXT3! EXCESS3! : -> PoseQueue .
  
  *** Check call to traverse-neighbour meets precondition (North)
  eq traverse-neighbours-vc1(P, START, CM, PM, TH, NEXT, EXCESS ,NEXT', EXCESS') =
    forall NP1! . ((
      traverse-neighbours-precond(P, START, CM, PM, TH, NEXT, EXCESS)
      and point-row(pose-position(P)) > 0
      and open(CM, point-row(pose-position(P)) - 1, point-col(pose-position(P)))
      and point-row(pose-position(NP1!)) === point-row(pose-position(P)) - 1
      and point-col(pose-position(NP1!)) === point-col(pose-position(P))
    ) implies (
      traverse-neighbour-precond(P, NP1!, START, CM, PM, TH, NEXT, EXCESS)
    )).
  
  *** Check call to traverse-neighbour meets precondition (South)
  eq traverse-neighbours-vc2(P, START, CM, PM, TH, NEXT, EXCESS ,NEXT', EXCESS') =
    forall NP1! . forall NEXT1! . forall EXCESS1! . 
    forall NP2! . ((
      traverse-neighbours-precond(P, START, CM, PM, TH, NEXT, EXCESS)
      and 
        ((point-row(pose-position(P)) > 0
          and open(CM, point-row(pose-position(P)) - 1, point-col(pose-position(P)))
          ) implies (
          point-row(pose-position(NP1!)) === point-row(pose-position(P)) - 1
          and point-col(pose-position(NP1!)) === point-col(pose-position(P))
          and traverse-neighbour-postcond(P, NP1!, START, CM, PM, TH, NEXT, EXCESS, NEXT1!, EXCESS1!)))
      and 
        ((not (point-row(pose-position(P)) > 0
          and open(CM, point-row(pose-position(P)) - 1, point-col(pose-position(P)))
          )) implies (
          NEXT1! === NEXT and EXCESS1! === EXCESS
          ))
      and point-row(pose-position(P)) < num-rows(CM) - 1
      and open(CM, point-row(pose-position(P)) + 1, point-col(pose-position(P)))
      and point-row(pose-position(NP2!)) === point-row(pose-position(P)) + 1
      and point-col(pose-position(NP2!)) === point-col(pose-position(P))
    ) implies (
      traverse-neighbour-precond(P, NP2!, START, CM, PM, TH, NEXT1!, EXCESS1!)
    )).
  
  *** Check call to traverse-neighbour meets precondition (West)
  eq traverse-neighbours-vc3(P, START, CM, PM, TH, NEXT, EXCESS ,NEXT', EXCESS') =
    forall NP1! . forall NEXT1! . forall EXCESS1! . 
    forall NP2! . forall NEXT2! . forall EXCESS2! . 
    forall NP3! . ((
      traverse-neighbours-precond(P, START, CM, PM, TH, NEXT, EXCESS)
      and 
        ((point-row(pose-position(P)) > 0
          and open(CM, point-row(pose-position(P)) - 1, point-col(pose-position(P)))
          ) implies (
          point-row(pose-position(NP1!)) === point-row(pose-position(P)) - 1
          and point-col(pose-position(NP1!)) === point-col(pose-position(P))
          and traverse-neighbour-postcond(P, NP1!, START, CM, PM, TH, NEXT, EXCESS, NEXT1!, EXCESS1!)))
      and 
        ((not (point-row(pose-position(P)) > 0
          and open(CM, point-row(pose-position(P)) - 1, point-col(pose-position(P)))
          )) implies (
          NEXT1! === NEXT and EXCESS1! === EXCESS
          ))
      and 
        ((point-row(pose-position(P)) < num-rows(CM) - 1
          and open(CM, point-row(pose-position(P)) + 1, point-col(pose-position(P)))
          ) implies (
          point-row(pose-position(NP2!)) === point-row(pose-position(P)) + 1
          and point-col(pose-position(NP2!)) === point-col(pose-position(P))
          and traverse-neighbour-postcond(P, NP2!, START, CM, PM, TH, NEXT1!, EXCESS1!, NEXT2!, EXCESS2!)))
      and 
        ((not (point-row(pose-position(P)) < num-rows(CM) - 1
          and open(CM, point-row(pose-position(P)) + 1, point-col(pose-position(P)))
          )) implies (
          NEXT2! === NEXT1! and EXCESS2! === EXCESS1!
          ))
      and point-col(pose-position(P)) > 0
      and open(CM, point-row(pose-position(P)), point-col(pose-position(P)) - 1)
      and point-row(pose-position(NP3!)) === point-row(pose-position(P))
      and point-col(pose-position(NP3!)) === point-col(pose-position(P)) - 1      
    ) implies (
      traverse-neighbour-precond(P, NP3!, START, CM, PM, TH, NEXT2!, EXCESS2!)      
    )).
    
  *** Check call to traverse-neighbour meets precondition (East)
  eq traverse-neighbours-vc4(P, START, CM, PM, TH, NEXT, EXCESS ,NEXT', EXCESS') =
    forall NP1! . forall NEXT1! . forall EXCESS1! . 
    forall NP2! . forall NEXT2! . forall EXCESS2! . 
    forall NP3! . forall NEXT3! . forall EXCESS3! . 
    forall NP4! . ((
      traverse-neighbours-precond(P, START, CM, PM, TH, NEXT, EXCESS)
      and 
        ((point-row(pose-position(P)) > 0
          and open(CM, point-row(pose-position(P)) - 1, point-col(pose-position(P)))
          ) implies (
          point-row(pose-position(NP1!)) === point-row(pose-position(P)) - 1
          and point-col(pose-position(NP1!)) === point-col(pose-position(P))
          and traverse-neighbour-postcond(P, NP1!, START, CM, PM, TH, NEXT, EXCESS, NEXT1!, EXCESS1!)))
      and 
        ((not (point-row(pose-position(P)) > 0
          and open(CM, point-row(pose-position(P)) - 1, point-col(pose-position(P)))
          )) implies (
          NEXT1! === NEXT and EXCESS1! === EXCESS
          ))
      and 
        ((point-row(pose-position(P)) < num-rows(CM) - 1
          and open(CM, point-row(pose-position(P)) + 1, point-col(pose-position(P)))
          ) implies (
          point-row(pose-position(NP2!)) === point-row(pose-position(P)) + 1
          and point-col(pose-position(NP2!)) === point-col(pose-position(P))
          and traverse-neighbour-postcond(P, NP2!, START, CM, PM, TH, NEXT1!, EXCESS1!, NEXT2!, EXCESS2!)))
      and 
        ((not (point-row(pose-position(P)) < num-rows(CM) - 1
          and open(CM, point-row(pose-position(P)) + 1, point-col(pose-position(P)))
          )) implies (
          NEXT2! === NEXT1! and EXCESS2! === EXCESS1!
          ))
      and 
        ((point-col(pose-position(P)) > 0
          and open(CM, point-row(pose-position(P)), point-col(pose-position(P)) - 1)
          ) implies (
          point-row(pose-position(NP3!)) === point-row(pose-position(P))
          and point-col(pose-position(NP3!)) === point-col(pose-position(P)) - 1
          and traverse-neighbour-postcond(P, NP3!, START, CM, PM, TH, NEXT2!, EXCESS2!, NEXT3!, EXCESS3!)))
      and 
        ((not (point-col(pose-position(P)) > 0
          and open(CM, point-row(pose-position(P)), point-col(pose-position(P)) - 1)
          )) implies (
          NEXT3! === NEXT2! and EXCESS3! === EXCESS2!
          ))
          
      and point-col(pose-position(P)) < num-cols(CM) - 1
      and open(CM, point-row(pose-position(P)), point-col(pose-position(P)) + 1)
      and point-row(pose-position(NP4!)) === point-row(pose-position(P))
      and point-col(pose-position(NP4!)) === point-col(pose-position(P)) + 1
    ) implies (
      traverse-neighbour-precond(P, NP4!, START, CM, PM, TH, NEXT3!, EXCESS3!)      
    )).
    
    *** Postcondition of traverse-neighbours
  eq traverse-neighbours-vc5(P, START, CM, PM, TH, NEXT, EXCESS ,NEXT', EXCESS') =
    forall NP1! . forall NEXT1! . forall EXCESS1! . 
    forall NP2! . forall NEXT2! . forall EXCESS2! . 
    forall NP3! . forall NEXT3! . forall EXCESS3! . 
    forall NP4! . ((
      traverse-neighbours-precond(P, START, CM, PM, TH, NEXT, EXCESS)
      and 
        ((point-row(pose-position(P)) > 0
          and open(CM, point-row(pose-position(P)) - 1, point-col(pose-position(P)))
          ) implies (
          point-row(pose-position(NP1!)) === point-row(pose-position(P)) - 1
          and point-col(pose-position(NP1!)) === point-col(pose-position(P))
          and traverse-neighbour-postcond(P, NP1!, START, CM, PM, TH, NEXT, EXCESS, NEXT1!, EXCESS1!)))
      and 
        ((not (point-row(pose-position(P)) > 0
          and open(CM, point-row(pose-position(P)) - 1, point-col(pose-position(P)))
          )) implies (
          NEXT1! === NEXT and EXCESS1! === EXCESS
          ))
      and 
        ((point-row(pose-position(P)) < num-rows(CM) - 1
          and open(CM, point-row(pose-position(P)) + 1, point-col(pose-position(P)))
          ) implies (
          point-row(pose-position(NP2!)) === point-row(pose-position(P)) + 1
          and point-col(pose-position(NP2!)) === point-col(pose-position(P))
          and traverse-neighbour-postcond(P, NP2!, START, CM, PM, TH, NEXT1!, EXCESS1!, NEXT2!, EXCESS2!)))
      and 
        ((not (point-row(pose-position(P)) < num-rows(CM) - 1
          and open(CM, point-row(pose-position(P)) + 1, point-col(pose-position(P)))
          )) implies (
          NEXT2! === NEXT1! and EXCESS2! === EXCESS1!
          ))
      and 
        ((point-col(pose-position(P)) > 0
          and open(CM, point-row(pose-position(P)), point-col(pose-position(P)) - 1)
          ) implies (
          point-row(pose-position(NP3!)) === point-row(pose-position(P))
          and point-col(pose-position(NP3!)) === point-col(pose-position(P)) - 1
          and traverse-neighbour-postcond(P, NP3!, START, CM, PM, TH, NEXT2!, EXCESS2!, NEXT3!, EXCESS3!)))
      and 
        ((not (point-col(pose-position(P)) > 0
          and open(CM, point-row(pose-position(P)), point-col(pose-position(P)) - 1)
          )) implies (
          NEXT3! === NEXT2! and EXCESS3! === EXCESS2!
          ))
      and 
        ((point-col(pose-position(P)) < num-cols(CM) - 1
          and open(CM, point-row(pose-position(P)), point-col(pose-position(P)) + 1)
          ) implies (
          point-row(pose-position(NP4!)) === point-row(pose-position(P))
          and point-col(pose-position(NP4!)) === point-col(pose-position(P)) + 1
          and traverse-neighbour-postcond(P, NP4!, START, CM, PM, TH, NEXT3!, EXCESS3!, NEXT', EXCESS')))
      and 
        ((not (point-col(pose-position(P)) < num-cols(CM) - 1
          and open(CM, point-row(pose-position(P)), point-col(pose-position(P)) + 1)
          )) implies (
          NEXT' === NEXT3! and EXCESS' === EXCESS3!
          ))
    ) implies (
      traverse-neighbours-postcond(P, START, CM, PM, TH, NEXT, EXCESS ,NEXT', EXCESS')
    )).  
endfm


fmod ASTAR-ITERATION-VERIF is
  protecting POSE-VERIF .
  protecting COSTMAP-VERIF .
  protecting POTENTIALMAP-VERIF .
  protecting POSE-QUEUE-VERIF .
  protecting MIN-VERTICAL-VERIF .
  protecting MIN-HORIZONTAL-VERIF .
  protecting MIN-INFINITY-VERIF .
  protecting MAX-INFINITY-VERIF .
  protecting UPDATE-POTENTIAL-VERIF .
  protecting TRAVERSE-NEIGHBOURS-VERIF .
  protecting REAL-INTEGER .
  
  op astar-iteration-precond : 
    Pose Pose CostMap PotentialMap PoseQueue PoseQueue PoseQueue Real Integer -> Boolean .
  op astar-iteration-postcond : 
    Pose Pose CostMap PotentialMap PoseQueue PoseQueue PoseQueue Real Integer PotentialMap -> Boolean .
    
  vars START GOAL : Pose .
  var CM : CostMap .
  var PM PM' : PotentialMap .
  vars CUR NEXT EXCESS : PoseQueue .
  var THRESHOLD : Real .
  var NIT : Integer .
  
  eq astar-iteration-precond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT) =
    *** Input invariants
    pose-axiom(START)
    and pose-axiom(GOAL)
    and costmap-axiom(CM)
    and potentialmap-axiom(PM)
    and queue-axiom(CUR)
    and queue-axiom(NEXT)
    and queue-axiom(EXCESS)
    and NIT >= 0
    ***  requires ValidPotentialMap(pot, costMap)
    and potentialmap-valid(PM, CM)
    ***  requires ValidQueue(current, pot, costMap) && ValidQueue(next, pot, costMap) && ValidQueue(excess, pot, costMap)
    and queue-valid(CUR, PM, CM)
    and queue-valid(NEXT, PM, CM)
    and queue-valid(EXCESS, PM, CM)
    ***  requires ValidCostMap(costMap)
    and costmap-valid(CM)
    ***  requires 0 <= start.pos.row < costMap.numRows && 0 <= start.pos.col < costMap.numCols
    and 0 <= point-row(pose-position(START))
    and point-row(pose-position(START)) < num-rows(CM)
    and 0 <= point-col(pose-position(START))
    and point-col(pose-position(START)) < num-cols(CM)
    ***  requires 0 <= goal.pos.row < costMap.numRows && 0 <= goal.pos.col < costMap.numCols
    and 0 <= point-row(pose-position(GOAL))
    and point-row(pose-position(GOAL)) < num-rows(CM)
    and 0 <= point-col(pose-position(GOAL))
    and point-col(pose-position(GOAL)) < num-cols(CM)    
    .

    
    eq astar-iteration-postcond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM') = 
      potentialmap-valid(PM', CM) .
      

    
    *** Case in which numIterations == 0
    op astar-iteration-vc1 : Pose Pose CostMap PotentialMap PoseQueue PoseQueue PoseQueue Real Integer PotentialMap -> Boolean .
    
    eq astar-iteration-vc1(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM') =
      (
        astar-iteration-precond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT)
        and NIT === 0
        and PM' === PM
      ) implies (
        astar-iteration-postcond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM')
      ) .


    *** Case in which the starting position has potential lower than infinity
    op astar-iteration-vc2 : Pose Pose CostMap PotentialMap PoseQueue PoseQueue PoseQueue Real Integer PotentialMap -> Boolean .
    
    eq astar-iteration-vc2(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM') =
      (
        astar-iteration-precond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT)
        and not (NIT === 0)
        and not isInfinity(elem(PM, point-row(pose-position(START)), point-col(pose-position(START))))
        and PM' === PM
      ) implies (      
        astar-iteration-postcond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM')
      ) .
      
    op CUR0! : -> Pose .
    op CURT! : -> PoseQueue .
    op EMPTYQ! : -> PoseQueue .
    
    *** Case in which current queue is non-empty, and front position is closed
    *** Check precondition of recursive call
    op astar-iteration-vc3 : Pose Pose CostMap PotentialMap PoseQueue PoseQueue PoseQueue Real Integer PotentialMap -> Boolean .
    
    eq astar-iteration-vc3(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM') =
      forall CUR0! . forall CURT! .
        ((
          astar-iteration-precond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT)
          and not (NIT === 0)
          and isInfinity(elem(PM, point-row(pose-position(START)), point-col(pose-position(START))))
          and not empty(CUR)
          and front(CUR, CUR0!)
          and not open(CM, point-row(pose-position(CUR0!)), point-col(pose-position(CUR0!)))
          and dequeue(CUR, CURT!)          
        ) implies (      
          astar-iteration-precond(START, GOAL, CM, PM, CURT!, NEXT, EXCESS, THRESHOLD, NIT))) .      

    *** Case in which current queue is non-empty, and front position is closed
    *** From recursive call follows postcondition
    op astar-iteration-vc4 : Pose Pose CostMap PotentialMap PoseQueue PoseQueue PoseQueue Real Integer PotentialMap -> Boolean .
    
    eq astar-iteration-vc4(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM') =
      forall CUR0! . forall CURT! .
        ((
          astar-iteration-precond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT)
          and not (NIT === 0)
          and isInfinity(elem(PM, point-row(pose-position(START)), point-col(pose-position(START))))
          and not empty(CUR)
          and front(CUR, CUR0!)
          and not open(CM, point-row(pose-position(CUR0!)), point-col(pose-position(CUR0!)))
          and dequeue(CUR, CURT!)          
          and astar-iteration-postcond(START, GOAL, CM, PM, CURT!, NEXT, EXCESS, THRESHOLD, NIT, PM')
        ) implies (  
          astar-iteration-postcond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM')
        )) .      
        
    *** Case in which current queue is non-empty, and front position is open
    *** Precondition of call to MinVertical holds
    op astar-iteration-vc5 : Pose Pose CostMap PotentialMap PoseQueue PoseQueue PoseQueue Real Integer PotentialMap -> Boolean .
    
    eq astar-iteration-vc5(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM') =
      forall CUR0! . forall CURT! .
        ((
          astar-iteration-precond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT)
          and not (NIT === 0)
          and isInfinity(elem(PM, point-row(pose-position(START)), point-col(pose-position(START))))
          and not empty(CUR)
          and front(CUR, CUR0!)
          and open(CM, point-row(pose-position(CUR0!)), point-col(pose-position(CUR0!)))
        ) implies (  
          min-vertical-precond(CUR0!, PM, CM, num-rows(CM))
        )) .
        
        
    ops MINV! MINH! : -> RealInf .

    *** Case in which current queue is non-empty, and front position is open
    *** Precondition of call to MinHorizontal holds
    op astar-iteration-vc6 : Pose Pose CostMap PotentialMap PoseQueue PoseQueue PoseQueue Real Integer PotentialMap -> Boolean .
    
    eq astar-iteration-vc6(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM') =
      forall CUR0! . forall CURT! . forall MINV! .
        ((
          astar-iteration-precond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT)
          and not (NIT === 0)
          and isInfinity(elem(PM, point-row(pose-position(START)), point-col(pose-position(START))))
          and not empty(CUR)
          and front(CUR, CUR0!)
          and open(CM, point-row(pose-position(CUR0!)), point-col(pose-position(CUR0!)))
          and min-vertical-postcond(CUR0!, PM, CM, num-rows(CM), MINV!)
        ) implies (  
          min-horizontal-precond(CUR0!, PM, CM, num-cols(CM))
        )) .
        
    
        
    *** Case in which current queue is non-empty, and front position is open
    *** assert minV != Infinity || minH != Infinity;
    op astar-iteration-vc7 : Pose Pose CostMap PotentialMap PoseQueue PoseQueue PoseQueue Real Integer PotentialMap -> Boolean .
    
    eq astar-iteration-vc7(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM') =
      forall CUR0! . forall CURT! . forall MINV! . forall MINH! .
        ((
          astar-iteration-precond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT)
          and not (NIT === 0)
          and isInfinity(elem(PM, point-row(pose-position(START)), point-col(pose-position(START))))
          and not empty(CUR)
          and front(CUR, CUR0!)
          and open(CM, point-row(pose-position(CUR0!)), point-col(pose-position(CUR0!)))
          and min-vertical-postcond(CUR0!, PM, CM, num-rows(CM), MINV!)
          and min-horizontal-postcond(CUR0!, PM, CM, num-cols(CM), MINH!)
        ) implies (  
          (not isInfinity(MINV!)) or (not isInfinity(MINH!))
        )) .
        
    
    ops MIN! SND! : -> RealInf .
    
    *** Case in which current queue is non-empty, and front position is open
    *** Precondition of UpdatePotential  holds
    op astar-iteration-vc8 : Pose Pose CostMap PotentialMap PoseQueue PoseQueue PoseQueue Real Integer PotentialMap -> Boolean .
    
    eq astar-iteration-vc8(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM') =
      forall CUR0! . forall CURT! . forall MINV! . forall MINH! . 
      forall MIN! . forall SND! .
        ((
          astar-iteration-precond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT)
          and not (NIT === 0)
          and isInfinity(elem(PM, point-row(pose-position(START)), point-col(pose-position(START))))
          and not empty(CUR)
          and front(CUR, CUR0!)
          and open(CM, point-row(pose-position(CUR0!)), point-col(pose-position(CUR0!)))
          and min-vertical-postcond(CUR0!, PM, CM, num-rows(CM), MINV!)
          and min-horizontal-postcond(CUR0!, PM, CM, num-cols(CM), MINH!)
          and ((not isInfinity(MINV!)) or (not isInfinity(MINH!)))
          and min-infinity(MINV!, MINH!, MIN!)
          and max-infinity(MINV!, MINH!, SND!)
        ) implies (  
          update-potential-precond(PM, CUR0!, GOAL, CM, MIN!, SND!)
        )) .
    
    
    op POTAUX! : -> PotentialMap .
    
    *** Case in which current queue is non-empty, and front position is open
    *** assert ValidQueue(current, potAux, costMap);
    *** assert ValidQueue(next, potAux, costMap);
    *** assert ValidQueue(excess, potAux, costMap);
    op astar-iteration-vc9 : Pose Pose CostMap PotentialMap PoseQueue PoseQueue PoseQueue Real Integer PotentialMap -> Boolean .
    
    
    eq astar-iteration-vc9(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM') =
      forall CUR0! . forall CURT! . forall MINV! . forall MINH! . 
      forall MIN! . forall SND! . forall POTAUX! .
        ((
          astar-iteration-precond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT)
          and not (NIT === 0)
          and isInfinity(elem(PM, point-row(pose-position(START)), point-col(pose-position(START))))
          and not empty(CUR)
          and front(CUR, CUR0!)
          and open(CM, point-row(pose-position(CUR0!)), point-col(pose-position(CUR0!)))
          and min-vertical-postcond(CUR0!, PM, CM, num-rows(CM), MINV!)
          and min-horizontal-postcond(CUR0!, PM, CM, num-cols(CM), MINH!)
          and ((not isInfinity(MINV!)) or (not isInfinity(MINH!)))
          and min-infinity(MINV!, MINH!, MIN!)
          and max-infinity(MINV!, MINH!, SND!)
          and update-potential-postcond(PM, CUR0!, GOAL, CM, MIN!, SND!, POTAUX!)
        ) implies (  
          queue-valid(CUR, POTAUX!, CM)
          and queue-valid(NEXT, POTAUX!, CM)
          and queue-valid(EXCESS, POTAUX!, CM)
        )) .
        
    *** Case in which current queue is non-empty, and front position is open
    *** Precondition of call to TraverseNeighbours holds
    op astar-iteration-vc10 : Pose Pose CostMap PotentialMap PoseQueue PoseQueue PoseQueue Real Integer PotentialMap -> Boolean .
        
    eq astar-iteration-vc10(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM') =
      forall CUR0! . forall CURT! . forall MINV! . forall MINH! . 
      forall MIN! . forall SND! . forall POTAUX! .
        ((
          astar-iteration-precond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT)
          and not (NIT === 0)
          and isInfinity(elem(PM, point-row(pose-position(START)), point-col(pose-position(START))))
          and not empty(CUR)
          and front(CUR, CUR0!)
          and open(CM, point-row(pose-position(CUR0!)), point-col(pose-position(CUR0!)))
          and min-vertical-postcond(CUR0!, PM, CM, num-rows(CM), MINV!)
          and min-horizontal-postcond(CUR0!, PM, CM, num-cols(CM), MINH!)
          and ((not isInfinity(MINV!)) or (not isInfinity(MINH!)))
          and min-infinity(MINV!, MINH!, MIN!)
          and max-infinity(MINV!, MINH!, SND!)
          and update-potential-postcond(PM, CUR0!, GOAL, CM, MIN!, SND!, POTAUX!)
          and queue-valid(CUR, POTAUX!, CM)
          and queue-valid(NEXT, POTAUX!, CM)
          and queue-valid(EXCESS, POTAUX!, CM)
        ) implies (
          traverse-neighbours-precond(CUR0!, START, CM, POTAUX!, THRESHOLD, NEXT, EXCESS)
        )) .        

        
    ops NEXT'! EXCESS'! : -> PoseQueue .
    
    *** Case in which current queue is non-empty, and front position is open
    *** assert ValidQueue(next', potAux, costMap);
    *** assert ValidQueue(excess', potAux, costMap);
    op astar-iteration-vc11 : Pose Pose CostMap PotentialMap PoseQueue PoseQueue PoseQueue Real Integer PotentialMap -> Boolean .
        
    eq astar-iteration-vc11(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM') =
      forall CUR0! . forall CURT! . forall MINV! . forall MINH! . 
      forall MIN! . forall SND! . forall POTAUX! .
      forall NEXT'! . forall EXCESS'! .
        ((
          astar-iteration-precond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT)
          and not (NIT === 0)
          and isInfinity(elem(PM, point-row(pose-position(START)), point-col(pose-position(START))))
          and not empty(CUR)
          and front(CUR, CUR0!)
          and open(CM, point-row(pose-position(CUR0!)), point-col(pose-position(CUR0!)))
          and min-vertical-postcond(CUR0!, PM, CM, num-rows(CM), MINV!)
          and min-horizontal-postcond(CUR0!, PM, CM, num-cols(CM), MINH!)
          and ((not isInfinity(MINV!)) or (not isInfinity(MINH!)))
          and min-infinity(MINV!, MINH!, MIN!)
          and max-infinity(MINV!, MINH!, SND!)
          and update-potential-postcond(PM, CUR0!, GOAL, CM, MIN!, SND!, POTAUX!)
          and queue-valid(CUR, POTAUX!, CM)
          and queue-valid(NEXT, POTAUX!, CM)
          and queue-valid(EXCESS, POTAUX!, CM)
          and traverse-neighbours-postcond(CUR0!, START, CM, POTAUX!, THRESHOLD, NEXT, EXCESS, NEXT'!, EXCESS'!)
        ) implies (
          queue-valid(NEXT'!, POTAUX!, CM)
          and queue-valid(EXCESS'!, POTAUX!, CM)
        )) .        

    *** Case in which current queue is non-empty, and front position is open
    *** Precondition of recursive call holds
    op astar-iteration-vc12 : Pose Pose CostMap PotentialMap PoseQueue PoseQueue PoseQueue Real Integer PotentialMap -> Boolean .
        
    eq astar-iteration-vc12(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM') =
      forall CUR0! . forall CURT! . forall MINV! . forall MINH! . 
      forall MIN! . forall SND! . forall POTAUX! .
      forall NEXT'! . forall EXCESS'! .
        ((
          astar-iteration-precond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT)
          and not (NIT === 0)
          and isInfinity(elem(PM, point-row(pose-position(START)), point-col(pose-position(START))))
          and not empty(CUR)
          and front(CUR, CUR0!)
          and open(CM, point-row(pose-position(CUR0!)), point-col(pose-position(CUR0!)))
          and min-vertical-postcond(CUR0!, PM, CM, num-rows(CM), MINV!)
          and min-horizontal-postcond(CUR0!, PM, CM, num-cols(CM), MINH!)
          and ((not isInfinity(MINV!)) or (not isInfinity(MINH!)))
          and min-infinity(MINV!, MINH!, MIN!)
          and max-infinity(MINV!, MINH!, SND!)
          and update-potential-postcond(PM, CUR0!, GOAL, CM, MIN!, SND!, POTAUX!)
          and queue-valid(CUR, POTAUX!, CM)
          and queue-valid(NEXT, POTAUX!, CM)
          and queue-valid(EXCESS, POTAUX!, CM)
          and traverse-neighbours-postcond(CUR0!, START, CM, POTAUX!, THRESHOLD, NEXT, EXCESS, NEXT'!, EXCESS'!)
          and queue-valid(NEXT'!, POTAUX!, CM)
          and queue-valid(EXCESS'!, POTAUX!, CM)
          and dequeue(CUR, CURT!)
        ) implies (
          astar-iteration-precond(START, GOAL, CM, POTAUX!, CURT!, NEXT'!, EXCESS'!, THRESHOLD, NIT)
        )) .

    *** Case in which current queue is non-empty, and front position is open
    *** Postcondition follows from recursive call
    op astar-iteration-vc13 : Pose Pose CostMap PotentialMap PoseQueue PoseQueue PoseQueue Real Integer PotentialMap -> Boolean .
        
    eq astar-iteration-vc13(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM') =
      forall CUR0! . forall CURT! . forall MINV! . forall MINH! . 
      forall MIN! . forall SND! . forall POTAUX! .
      forall NEXT'! . forall EXCESS'! .
        ((
          astar-iteration-precond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT)
          and not (NIT === 0)
          and isInfinity(elem(PM, point-row(pose-position(START)), point-col(pose-position(START))))
          and not empty(CUR)
          and front(CUR, CUR0!)
          and open(CM, point-row(pose-position(CUR0!)), point-col(pose-position(CUR0!)))
          and min-vertical-postcond(CUR0!, PM, CM, num-rows(CM), MINV!)
          and min-horizontal-postcond(CUR0!, PM, CM, num-cols(CM), MINH!)
          and ((not isInfinity(MINV!)) or (not isInfinity(MINH!)))
          and min-infinity(MINV!, MINH!, MIN!)
          and max-infinity(MINV!, MINH!, SND!)
          and update-potential-postcond(PM, CUR0!, GOAL, CM, MIN!, SND!, POTAUX!)
          and queue-valid(CUR, POTAUX!, CM)
          and queue-valid(NEXT, POTAUX!, CM)
          and queue-valid(EXCESS, POTAUX!, CM)
          and traverse-neighbours-postcond(CUR0!, START, CM, POTAUX!, THRESHOLD, NEXT, EXCESS, NEXT'!, EXCESS'!)
          and queue-valid(NEXT'!, POTAUX!, CM)
          and queue-valid(EXCESS'!, POTAUX!, CM)
          and dequeue(CUR, CURT!)
          and astar-iteration-postcond(START, GOAL, CM, POTAUX!, CURT!, NEXT'!, EXCESS'!, THRESHOLD, NIT, PM')
        ) implies (
          astar-iteration-postcond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM')
        )) .
        
    *** Case in which current queue is empty, and so is next queue
    *** Check precondition of recursive call
    op astar-iteration-vc14 : Pose Pose CostMap PotentialMap PoseQueue PoseQueue PoseQueue Real Integer PotentialMap -> Boolean .
    
    eq astar-iteration-vc14(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM') =
      forall EMPTYQ! .
        ((
          astar-iteration-precond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT)
          and not (NIT === 0)
          and isInfinity(elem(PM, point-row(pose-position(START)), point-col(pose-position(START))))
          and empty(CUR)
          and empty(NEXT)
          and empty(EMPTYQ!)
        ) implies (  
          astar-iteration-precond(START, GOAL, CM, PM, EXCESS, EMPTYQ!, NEXT, THRESHOLD + toReal(2) * map-cost , NIT - 1)
        )) .      

    *** Case in which current queue is empty, and so is next queue
    *** From recursive call follows postcondition
    op astar-iteration-vc15 : Pose Pose CostMap PotentialMap PoseQueue PoseQueue PoseQueue Real Integer PotentialMap -> Boolean .
    
    eq astar-iteration-vc15(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM') =
      forall EMPTYQ! .
        ((
          astar-iteration-precond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT)
          and not (NIT === 0)
          and isInfinity(elem(PM, point-row(pose-position(START)), point-col(pose-position(START))))
          and empty(CUR)
          and empty(NEXT)
          and empty(EMPTYQ!)
          and astar-iteration-postcond(START, GOAL, CM, PM, EXCESS, EMPTYQ!, NEXT, THRESHOLD + toReal(2) * map-cost , NIT - 1, PM')
        ) implies (  
          astar-iteration-postcond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM')
        )) .      
        
    *** Case in which current queue is empty, but next is not
    *** Check precondition of recursive call
    op astar-iteration-vc16 : Pose Pose CostMap PotentialMap PoseQueue PoseQueue PoseQueue Real Integer PotentialMap -> Boolean .
    
    eq astar-iteration-vc16(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM') =
      forall EMPTYQ! .
        ((
          astar-iteration-precond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT)
          and not (NIT === 0)
          and isInfinity(elem(PM, point-row(pose-position(START)), point-col(pose-position(START))))
          and empty(CUR)
          and not empty(NEXT)
          and empty(EMPTYQ!)
        ) implies (  
          astar-iteration-precond(START, GOAL, CM, PM, NEXT, EMPTYQ!, EXCESS, THRESHOLD, NIT - 1)
        )) .
        
    
    *** Case in which current queue is empty, but next is not
    *** From recursive call follows postcondition
    op astar-iteration-vc17 : Pose Pose CostMap PotentialMap PoseQueue PoseQueue PoseQueue Real Integer PotentialMap -> Boolean .
    
    eq astar-iteration-vc17(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM') =
      forall EMPTYQ! .
        ((
          astar-iteration-precond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT)
          and not (NIT === 0)
          and isInfinity(elem(PM, point-row(pose-position(START)), point-col(pose-position(START))))
          and empty(CUR)
          and not empty(NEXT)
          and empty(EMPTYQ!)
          and astar-iteration-postcond(START, GOAL, CM, PM, NEXT, EMPTYQ!, EXCESS, THRESHOLD, NIT - 1, PM')
        ) implies (  
          astar-iteration-postcond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, THRESHOLD, NIT, PM')
        )) .
endfm


fmod ASTAR-VERIF is
  protecting POSE-VERIF .
  protecting POTENTIALMAP-VERIF .
  protecting COSTMAP-VERIF .
  protecting POSE-QUEUE-VERIF .
  protecting BUILD-INITIAL-POTENTIAL-MAP-VERIF .
  protecting EUCLID-DISTANCE-VERIF .
  protecting INIT-CURRENT-QUEUE-VERIF .
  protecting ASTAR-ITERATION-VERIF .
  
  op astar-precond : Pose Pose CostMap Integer -> Boolean .
  
  var START GOAL : Pose .
  var CM : CostMap .
  var NI : Integer .
  var PM : PotentialMap .
  vars ITHR ITHR' : Real .
  var CUR NEXT EXCESS : PoseQueue .
  

  
  eq astar-precond(START, GOAL, CM, NI) =
    *** Input invariants
        NI >= 0
    and pose-axiom(START)
    and pose-axiom(GOAL)
    *** Preconditions
    and 0 <= point-row(pose-position(START))        
    and point-row(pose-position(START)) < num-rows(CM)
    and 0 <= point-col(pose-position(START))
    and point-col(pose-position(START)) < num-cols(CM)
    and 0 <= point-row(pose-position(GOAL))        
    and point-row(pose-position(GOAL)) < num-rows(CM)
    and 0 <= point-col(pose-position(GOAL))
    and point-col(pose-position(GOAL)) < num-cols(CM)
    and open(CM, point-row(pose-position(GOAL)), point-col(pose-position(GOAL)))
    and costmap-valid(CM) .
  
  *** Call to BuildInitialPotentialMap meets preconditions
  op astar-vc1 : Pose Pose CostMap Integer PotentialMap Real Real PoseQueue PoseQueue PoseQueue -> Boolean .
  eq astar-vc1(START, GOAL, CM, NI, PM, ITHR, ITHR', CUR, NEXT, EXCESS) =
    (
      astar-precond(START, GOAL, CM, NI)
    ) implies (
      build-initial-potential-map-precond(num-rows(CM), num-cols(CM), point-row(pose-position(GOAL)), point-col(pose-position(GOAL))) 
    ) .
    
  *** Call to EuclidDistance meets preconditions
  op astar-vc2 : Pose Pose CostMap Integer PotentialMap Real Real PoseQueue PoseQueue PoseQueue -> Boolean .
  eq astar-vc2(START, GOAL, CM, NI, PM, ITHR, ITHR', CUR, NEXT, EXCESS) =
    (
      astar-precond(START, GOAL, CM, NI)
      and build-initial-potential-map-postcond(num-rows(CM), num-cols(CM), point-row(pose-position(GOAL)), point-col(pose-position(GOAL)), PM)
    ) implies (
      euclid-distance-precond(pose-position(START), pose-position(GOAL))
    ) .
  
  *** Call to InitCurrentQueue meets preconditions
  op astar-vc3 : Pose Pose CostMap Integer PotentialMap Real Real PoseQueue PoseQueue PoseQueue -> Boolean .
  eq astar-vc3(START, GOAL, CM, NI, PM, ITHR, ITHR', CUR, NEXT, EXCESS) =
    (
      astar-precond(START, GOAL, CM, NI)
      and build-initial-potential-map-postcond(num-rows(CM), num-cols(CM), point-row(pose-position(GOAL)), point-col(pose-position(GOAL)), PM)
      and euclid-distance-postcond(pose-position(START), pose-position(GOAL), ITHR)
      and ITHR' === ITHR + obstacle-cost
    ) implies (
      init-current-queue-precond(GOAL, PM, CM)
    ) .
  
  *** Call to AStarIteration meets preconditions
  op astar-vc4 : Pose Pose CostMap Integer PotentialMap Real Real PoseQueue PoseQueue PoseQueue -> Boolean .
  eq astar-vc4(START, GOAL, CM, NI, PM, ITHR, ITHR', CUR, NEXT, EXCESS) =
    (
      astar-precond(START, GOAL, CM, NI)
      and build-initial-potential-map-postcond(num-rows(CM), num-cols(CM), point-row(pose-position(GOAL)), point-col(pose-position(GOAL)), PM)
      and euclid-distance-postcond(pose-position(START), pose-position(GOAL), ITHR)
      and ITHR' === ITHR + obstacle-cost
      and init-current-queue-postcond(GOAL, PM, CM, CUR)
      and empty(NEXT)
      and empty(EXCESS)
    ) implies (
      astar-iteration-precond(START, GOAL, CM, PM, CUR, NEXT, EXCESS, ITHR', NI)
    ) .
  
endfm


