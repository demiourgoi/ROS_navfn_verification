load common.maude

***(
   The algorithm assumes the number of iterations and the "inflated" map (including limits) are given by the user.
   The (0,0) position is on the upper-left corner.
)
mod ASTAR is
 pr GRADIENT-TRAVERSAL .
 pr GRADIENT .
 pr EXT-BOOL .
 pr COSTMAP .

 vars V V' T FI FI' MINV SNDV DC HF D DX DY DX' DY' DX'' DY'' DDX DDY SS FX FY FZ FX' FY' FZ' : Float .
 vars CURR NEXT EXC NEXT' EXC' P1L P1R P2L P2R P3L P3R P4L P4R PT : Path .
 vars X Y Z X' Y' Z' XI YI XC YC XN YN NR NC I IPATH NEW N : Nat .
 vars INIT GOAL ACCP : Pose .
 vars Q Q' : Quaternion .
 vars P P' : Potential .
 var  G : Gradient .
 var  CM : CostMap .

 sort TraversalResult .
 op <_,_> : Path Path -> TraversalResult [ctor] .

 ***     Init Goal         NumRow NumCol Iterations Iterations path
 op a* : Pose Pose CostMap  Nat    Nat      Nat     Nat -> Path .
 *** For model checking
 op a* : Pose Pose Gradient  Nat Nat Nat Potential -> Path .
 rl a*({FX, FY, FZ} Q, {FX', FY', FZ'} Q', CM, NC, NR, I, IPATH) =>
         a*({float2nat(FX), float2nat(FY), float2nat(FZ)} Q,
            {float2nat(FX'), float2nat(FY'), float2nat(FZ')} Q', CM, NC, NR, I, IPATH) .
 crl a*({X, Y, Z} Q, {X', Y', Z'} Q', CM, NC, NR, I, IPATH) => *** computePath({X, Y, Z} Q, {X', Y', Z'} Q', P', NC, NR)
                                                               *** computePath(P', {X, Y}, {X', Y'}, stepSize, G, NC, NR, IPATH)
                                                               a*({X, Y}, {X', Y'}, G, NC, NR, IPATH, P')
  if P := initialP*(NC, NR, X', Y') /\
     T := h({X, Y, Z} Q, {X', Y', Z'} Q') + obstacleCost /\
     CURR := initCurrent({X', Y'}, CM, NC, NR) /\
     a*({X, Y}, {X', Y'}, CM, P, NC, NR, CURR, noPath, noPath, T, I) => P' /\
     (P' @ [X , Y]) < infinite /\
     G := initialGradient(NC, NR) [label initPath] .
 crl a*({X, Y, Z} Q, {X', Y', Z'} Q', CM, NC, NR, I, IPATH) => noPath
  if P := initialP*(NC, NR, X', Y') /\
     T := h({X, Y, Z} Q, {X', Y', Z'} Q') + obstacleCost /\
     CURR := initCurrent({X', Y'}, CM, NC, NR) /\
     P' := a*({X, Y}, {X', Y'}, CM, P, NC, NR, CURR, noPath, noPath, T, I) /\
     (P' @ [X , Y]) == infinite .
 rl a*({X, Y}, {X', Y'}, G, NC, NR, IPATH, P) => computePath(P, {X, Y}, {X', Y'}, stepSize, G, NC, NR, IPATH) .

 op initCurrent : Pose CostMap Nat Nat -> Path .
 ceq initCurrent({X, Y}, CM, NC, NR) = P2L P1L P3L P4L
  if P1L := if (X > 0) and-then open?(CM, sd(X, 1), Y, NC)
            then {sd(X, 1), Y}
            else noPath
            fi /\
     P2L := if (s(X) < NC) and-then open?(CM, s(X), Y, NC)
            then {s(X), Y}
            else noPath
            fi /\
     P3L := if (Y > 0) and-then open?(CM, X, sd(Y, 1), NC)
            then {X, sd(Y, 1)}
            else noPath
            fi /\
     P4L := if (s(Y) < NR) and-then open?(CM, X, s(Y), NC)
            then {X, s(Y)}
            else noPath
            fi .

  op getPotential : Pose Pose CostMap Nat Nat Nat -> Potential .
  eq getPotential({FX, FY, FZ} Q, {FX', FY', FZ'} Q', CM, NC, NR, I) =
         getPotential({float2nat(FX), float2nat(FY), float2nat(FZ)} Q,
            {float2nat(FX'), float2nat(FY'), float2nat(FZ')} Q', CM, NC, NR, I) .
  ceq getPotential({X, Y, Z} Q, {X', Y', Z'} Q', CM, NC, NR, I) = a*({X, Y}, {X', Y'}, CM, P, NC, NR, CURR, noPath, noPath, T, I)
   if P := initialP*(NC, NR, X', Y') /\
      T := h({X, Y, Z} Q, {X', Y', Z'} Q') + obstacleCost /\
      CURR := initCurrent({X', Y'}, CM, NC, NR) .

 *** Initial a* term
 op a*i : Pose Pose CostMap Nat Nat Nat ~> Potential .
 ceq a*i({X, Y}, {X', Y'}, CM, NC, NR, I) = a*({X, Y}, {X', Y'}, CM, P, NC, NR, CURR, noPath, noPath, T,  I)
  if P := initialP*(NC, NR, X', Y') /\
     T := h({X, Y, 0} 0, {X', Y', 0} 0) + obstacleCost /\
     CURR := initCurrent({X', Y'}, CM, NC, NR) .

 ***     Init                        NumRow NumCol  Current  Next   Excess  Threshold  Iterations
 op a* : Pose Pose CostMap Potential  Nat     Nat   Path Path Path   Float       Nat  ~> Potential .
 rl [reached] : a*(INIT, GOAL, CM, P, NC, NR, CURR, NEXT, EXC, T, 0) => P .
 crl [reached] : a*({X, Y}, GOAL, CM, P, NC, NR, noPath, NEXT, EXC, T, I) => P
  if D := P @ [X , Y] /\
     D =/= infinite .
 crl [curr] : a*(INIT, GOAL, CM, P, NC, NR, ({X, Y} CURR), NEXT, EXC, T, s(I)) => a*(INIT, GOAL, CM, P, NC, NR, CURR, NEXT, EXC, T, s(I))
  if not open?(CM, X, Y, NC) .
 crl [curr] :  a*(INIT, GOAL, CM, P, NC, NR, ({X, Y} CURR), NEXT, EXC, T, s(I)) =>
                        a*(INIT, GOAL, CM, P', NC, NR, CURR, NEXT', EXC', T, s(I))
  if open?(CM, X, Y, NC) /\
     FI := minv({X, Y}, P, NR) /\
     FI' := minh({X, Y}, P, NC) /\
     MINV := min(FI, FI') /\
     SNDV := max(FI, FI') /\
     P' := updatePotential(P, {X,Y}, GOAL, CM, NC, MINV, SNDV) /\
     < NEXT', EXC' > :=  if P @ [X, Y] > P' @ [X, Y]
                         then traverseNeighbors({X, Y}, INIT, CM, P', NC, NR, T, NEXT, EXC)
                         else < NEXT, EXC >
                         fi .
 rl [next] : a*(INIT, GOAL, CM, P, NC, NR, noPath, NEXT, EXC, T, s(I)) =>
         if NEXT == noPath
         then a*(INIT, GOAL, CM, P, NC, NR, EXC, noPath, NEXT, T + 2.0 * mapCost, I)
         else a*(INIT, GOAL, CM, P, NC, NR, NEXT, noPath, EXC, T, I)
         fi .

 ***                   Current  INIT
 op traverseNeighbors : Pose    Pose CostMap Potential Nat Nat Float Path Path -> TraversalResult .
 ceq traverseNeighbors({X, Y}, INIT, CM, P, NC, NR, T, NEXT, EXC) = < NEXT P1L P2L P3L P4L, EXC P1R P2R P3R P4R >
  if < P1L, P1R > := if (X > 0) and-then open?(CM, sd(X,1), Y, NC) and-then not ({sd(X,1), Y} in NEXT) and-then not ({sd(X,1), Y} in EXC)
                     then traverseNeighbor({X, Y}, {sd(X,1), Y}, INIT, CM, P, NC, T)
                     else < noPath, noPath >
                     fi /\
     < P2L, P2R > := if (s(X) < NC) and-then open?(CM, s(X), Y, NC) and-then not ({s(X), Y} in NEXT) and-then not ({s(X), Y} in EXC)
                     then traverseNeighbor({X, Y}, {s(X), Y}, INIT, CM, P, NC, T)
                     else < noPath, noPath >
                     fi /\
     < P3L, P3R > := if Y > 0 and-then open?(CM, X, sd(Y,1), NC) and-then not ({X, sd(Y,1)} in NEXT) and-then not ({X, sd(Y,1)} in EXC)
                     then traverseNeighbor({X, Y}, {X, sd(Y,1)}, INIT, CM, P, NC, T)
                     else < noPath, noPath >
                     fi /\
     < P4L, P4R > := if s(Y) < NR and-then open?(CM, X, s(Y), NC) and-then not ({X, s(Y)} in NEXT) and-then not ({X, s(Y)} in EXC)
                     then traverseNeighbor({X, Y}, {X, s(Y)}, INIT, CM, P, NC, T)
                     else < noPath, noPath > fi .

 op traverseNeighbor : Pose Pose Pose CostMap Potential Nat Float -> TraversalResult .
 ceq traverseNeighbor({XC, YC}, {XN, YN}, {XI, YI}, CM, P, NC, T) = < noPath, noPath >
  if (P @ [XN, YN]) <= (P @ [XC, YC]) + h({XC, YC}, {XI, YI}) + (1.0 / sqrt(2.0)) * get(CM, XN, YN, NC) [print "No update vecino"] .
 eq traverseNeighbor({XC, YC}, {XN, YN}, {XI, YI}, CM, P, NC, T) =
                                   if (P @ [XC, YC]) + h({XC, YC}, {XI, YI}) < T
                                   then < {XN, YN}, noPath >
                                   else < noPath, {XN, YN} >
                                   fi [owise] .

 ***                                                   MINV  SNDV
 op updatePotential : Potential Pose Pose CostMap Nat Float Float  -> Potential .
 ceq updatePotential(P, {X,Y}, GOAL, CM, NC, MINV, SNDV) = P'
  if V := get(CM, X, Y, NC) /\
     _-_(SNDV, MINV) >= V /\
     V' := V + MINV /\
     P' := P [X ; Y \\ V'] .
 ceq updatePotential(P, {X,Y}, GOAL, CM, NC, MINV, SNDV) = P'
  if DC := _-_(SNDV, MINV) /\
     HF := get(CM, X, Y, NC) /\
     DC < HF /\
     D := DC / HF /\
     V := - 0.2301 * D * D + 0.5307 * D + 0.7040 /\
     V' := MINV + HF * V /\
     P' := P [X ; Y \\ V'] .

 op minh : Pose Potential Nat -> Float .
 ceq minh({X, Y}, P, NC) = min(FI, FI')
  if FI := if X > 0 then P @ [sd(X,1), Y] else infinite fi /\
     FI' := if s(X) < NC then P @ [s(X), Y] else infinite fi .

 op minv : Pose Potential Nat -> Float .
 ceq minv({X, Y}, P, NR) = min(FI, FI')
  if FI := if Y > 0 then P @ [X, sd(Y,1)] else infinite fi /\
     FI' := if s(Y) < NR then P @ [X, s(Y)] else infinite fi .

endm

*** set print attribute on .

*** (rew a*({2, 2, 0} 90, {0, 0, 0} 90, {50, 50,  50,  50,
                                    50, 254, 254, 50,
                                    50, 50,  50,  50,
                                    50, 50,  50,  50}, 4, 4, 30, 30) .)

load model-checker.maude

mod PROPS-POT is
 pr SATISFACTION .
 pr ASTAR .

 subsort Potential < State .

 vars CURR NEXT EXC : Path .
 vars NR NC N X Y : Nat .
 vars INIT GOAL : Pose .
 var  P : Potential .
 var  CM : CostMap .
 var  PATH : Path .
 var  T : Float .

 ops wallInCurrent wallInNext wallInExcess : -> Prop [ctor] .
 ceq a*(INIT, GOAL, CM, P, NC, NR, {X, Y} CURR, NEXT, EXC, T, N) |= wallInCurrent = true
  if not open?(CM, X, Y, NC) .
 ceq a*(INIT, GOAL, CM, P, NC, NR, CURR, {X, Y} NEXT, EXC, T, N) |= wallInNext = true
  if not open?(CM, X, Y, NC) .
 ceq a*(INIT, GOAL, CM, P, NC, NR, CURR, NEXT, {X, Y} EXC, T, N) |= wallInExcess = true
  if not open?(CM, X, Y, NC) .
endm

mod TEST-POT is
 pr LTL-SIMPLIFIER .
 pr MODEL-CHECKER .
 pr PROPS-POT .

 op initPot : -> Potential .
 eq initPot = a*i({2, 2}, {0,0}, {10, 10,  10,  10,
                                  10, 255, 255, 10,
                                  10, 10,  10,  10,
                                  10, 10,  10,  10}, 4, 4, 30) .
endm

*** red modelCheck(initPot, [] (~ wallInCurrent /\ ~ wallInNext /\ ~ wallInExcess)) .

mod PROPS-PATH is
 pr SATISFACTION .
 pr ASTAR .

 subsort Path < State .

 vars POSE POSE' INIT GOAL : Pose .
 var  CURR NEXT EXC PATH : Path .
 vars NR NC N X Y I : Nat .
 var  P : Potential .
 var  G : Gradient .
 var  CM : CostMap .
 var  T : Float .

 op PathComputed : -> Prop [ctor] .
 eq PATH |= PathComputed = reducedAndNotEmpty(PATH) .

 op reducedAndNotEmpty : Path -> Bool .
 eq reducedAndNotEmpty(noPath) = false .
 eq reducedAndNotEmpty(POSE) = true .
 eq reducedAndNotEmpty(POSE POSE' PATH) = reducedAndNotEmpty(POSE' PATH) .

 op NonInfinitePotAtInit : -> Prop [ctor] .
 eq a*({X, Y}, GOAL, G, NC, NR, I, P) |= NonInfinitePotAtInit = P @ [X, Y] < infinite .
endm

mod TEST-PATH is
 pr LTL-SIMPLIFIER .
 pr MODEL-CHECKER .
 pr PROPS-PATH .

 op initPath : -> Path .
 eq initPath = a*({2, 2, 0} 90, {0, 0, 0} 90,
                                   {50, 50,  50,  50,
                                    50, 254, 254, 50,
                                    50, 50,  50,  50,
                                    50, 50,  50,  50}, 4, 4, 30, 30) .
endm

*** red modelCheck(initPath, [] (NonInfinitePotAtInit -> <> PathComputed)) .

















